# get_next_line 함수 구현하기
파일을 읽어들이고, 거기서 \n (개행) 전의 한 줄씩 뽑아오는 함수

정적 변수를 얼마나 적절하게 사용하느냐 가 관건

<br>

## Prototype
- **int get_next_line(int fd, char \*\*line);**
- fd는 읽어들일 파일의 디스크립터
- line은 읽은 값 (문자열) 하나가 저장된 주소값
	- 주소값에 접근하면 string 한 개의 시작 주소값이 들어있 음
- 반환값
	- 한 라인이 읽혔을 때 : 1
	- EOF에 도달했을 때 : 0
	- 에러가 발생했을 때 : -1

<br>

## 주의사항
- libft 사용 금지!!
	- 필요한 함수는 get_next_line_utils.c에 적절히 정의하여 사용해야 한다
- 컴파일은 **gcc -Wall -Wextra -Werror -D BUFFER_SIZE=32 get_next_line.c get_next_line_utils.c** 로 진행
	- BUFFER_SIZE는 헤더에서 미리 정의할 필요가 굳이 없다 (-D 플래그를 사용하면, 새로운 매크로 상수를 헤더에 추가해주는 것과 진배없음)
	- BUFFER_SIZE를 사전 정의하거나 플래그를 사용해서 넣지 않으면 컴파일 에러가 발생하므로, 뮬리넷에서 무조건 -D 플래그를 사용해서 컴파일할듯? (이부분에 대한 예외처리는 해주지 않아도 될 것 같다..)
- get_next_line을 새로 불러올 때마다, 개행 뒤의 나머지 문자열을 연속해서 불러와야 함 <- static 변수 사용 이유
	- static 변수는 함수 초기화가 아닌, 프로그램 시작과 동시에 한번만 초기화되므로, 함수를 계속 불러와주어도 내부의 static 변수 안에 들은 값은 변동이 없다
	- 따라서, get_next_line 함수 내에 문자열을 저장하는 static 변수가 있다면, get_next_line을 새로 불러와도 저장된 문자열 주소가 사라지지 않음
	- 마치 전역변수 같은 느낌? (해당 과제에서 전역변수 사용은 금지됨)
- fd의 종류는 최대 256가지 (클러스터 맥 환경에서)
	- limits.h 내부의 OPEN_MAX 상수를 써도 되지만, 사용자가 임의로 변경가능한 상수라 안전하지 않다
```
get_next_line이 호출될 때마다 가능한 한 적게 읽어들이도록 해야 합니다. 만약 newline을 만나면, 현재 라인을 반환해야 합니다. 전체 파일을 읽어들인 다음에 한줄씩 처리하려 하지 마세요.
```
- 이 부분을 조심 : 전체 파일을 무작정 큰 버퍼에 담은 뒤 한 줄씩 파싱하는 것을 자제하자
	- 이것때문에 새로 다시짰다... 그 흔적은 prototype_get_next_line 폴더에...
- 메모리 누수 주의 : gnlTester에서 메모리 누수를 잡아주기도 함
	- 외에도 적당한 main문 걸어놓고 -fsanitizer=address 이용해서 잡아주는 방법도..


### 구현 순서
1. static char *str_buf[fd] 변수에 들어가는 값 (문자열 주소)
	- 처음 불러왔을 땐, strdup 이용해서 빈 문자열의 포인터를 넣어준다 (나중에 strjoin 위함)
	- 버퍼 사이즈만큼 buf[BUFFER_SIZE + 1] 에서 읽어준 값을 static 변수와 join하여, 해당 포인터를 static 변수에 넘겨주고, 이때 문자열에 '\n'이 포함되어 있는지 검사
		- static 변수에 새로운 포인터를 넘겨줄 때마다 이전에 들어있던 포인터는 free시켜주어야 한다
	- 문자열에 '\n'이 들어 있다면, '\n' 이전까지의 값만 읽어서 line에 넣어주고, 나머지 문자열을 static에 저장
2. 개행 문자 전까지 string 복사하여 line 주소에 넣어주기
	- strchr 이용하여 '\n'을 가리키는 포인터를 얻어온 후, str_buf[fd] 의 초기 포인터와 서로 빼서 문장의 길이를 구한다
	- 구한 길이만큼만 새 메모리에 복사하기 위해서 strndup 사용, line에 주소값을 넘겨준 후 반환
	- 복사가 완료되면, str_buf[fd]에 저장되어 있던 문자열 중 line에 넘겨준 한 줄만큼은 더이상 필요가 없기 때문에 우선 str_buf[fd] 메모리 해제
	- 해제 후, strchr로 얻어온 '\n' 포인터 다음부터 strdup하여 해당 주소값을 str_buf[fd]에 저장
3. 개행이 아니라 EOF를 만났을 경우
	- while (len_read > 0)에서 빠져나오기 때문에 (len_read 가 read의 반환값 저장) 그 다음에 str_buf[fd]에 저장되어 있던 버퍼값들을 line에 dup하여 반환해주기만 하면 된다
	- 마지막에 str_buf free 및 훗날 재사용을 위해 0으로 초기화는 필수
4. 예외사항
	- read에 실패했을 때, fd가 지나치게 크거나 (256 이상 / 0 미만) line 이중포인터가 널일 때
	- 버퍼 사이즈가 1보다 작을 때
	- malloc 할당 실패
