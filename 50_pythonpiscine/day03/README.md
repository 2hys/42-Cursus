# **D03 - Piscine Python-Django**

파이썬-쟝고 연습 (파이썬 - 라이브러리들)

_요약: 오늘은 파이썬에서 유용하게 사용할 만한 라이브러리를 다루는 법을 알아보죠._

<br>

# Contents

| Chapter | Contents | page|
| :----:| :------- | :------: |
| 1 | [**Preamble**](#Chapter-1) | 2 |
| 2 | [**Instructions**](#Chapter-2) | 3 |
| 3 | [**Today's specific rules**](#Chapter-3) | 4 |
| 4 | [**Exercise 00**](#Chapter-4) | 5 |
| 5 | [**Exercise 01**](#Chapter-5) | 6 |
| 6 | [**Exercise 02**](#Chapter-6) | 8 |
| 7 | [**Exercise 03**](#Chapter-7) | 10 |
| 8 | [**Exercise 04**](#Chapter-8) | 13 |
| 9 | [**Exercise 05**](#Chapter-9) | 14 |

<br>

# **Chapter 1**

## Preamble

<br>

지오해싱 - 위키피디아, 지식의 백과사전

```
(대충 지오해싱은 xkcd 커뮤니티 유저들의 문화이고, 지오해싱을 거쳐서 나온 위도와 경도에 해당하는 위치에 방문하여 인증샷을 남기는 게임이라는 내용)
```
[심심하면 읽어보세요](https://en.wikipedia.org/wiki/Geohashing)


<br>

# **Chapter 2**

## Instructions

<br>

노골적인 모순이 없는 이상, 해당 지침은 Python Django Piscine 모든 날짜에 적용됩니다.

- 이 페이지에 있는 내용만이 레퍼런스로 적용됩니다. 루머를 믿지 마세요!

- 조심하세요! 과제를 제출하기 한 시간 전까지도 해당 문서는 변경될 수 있습니다.

- 이번 과제들은 난이도별로 배치되어 있습니다 - 쉬운 것부터 어려운 것 까지요. 만약 쉬운 과제가 제대로 작동하지 않으면, `우리는 절 대` 어려운 과제를 (완벽하게 구현하였더라도) 채점하지 않을 것입니다.

- 파일과 디렉토리에 적절한 권한 설정을 해 주었는지 확인하세요.

- 각 과제별로 **제출 필수사항**을 지키셔야 합니다.

- 여러분의 과제는 같은 피씨너들에게 채점받고 점수가 매겨질 것입니다.

- 그리고 그 뒤에, 뮬리넷이라는 프로그램에 의해 채점되고 점수가 매겨질 것입니다. 뮬리넷은 여러분의 과제를 정말 엄격하고 꼼꼼하게 채점할 것입니다. 또한 모든 작업은 자동으로 진행되므로, 여러분이 뮬리넷과 협상하는 것은 불가능합니다. 좋지 못한 결과를 깜짝 선물로 받고 싶지 않다면, 철저히 과제에 임하세요.

- 쉘 과제들은 `/bin/sh`에 의해 실행될 수 있어야 합니다.

- 여러분은 **절대로** 명시된 제출 파일 외의 다른 파일들을 폴더 내에 남겨두시면 **안됩니다.**

- 질문 있으세요? 오른쪽 동료에게 물어보세요. 아니면 왼쪽 동료한테 물어보세요.

- 여러분이 참고할 만한 가이드는 `Google / man / 인터넷` 등이 있습니다.

- 인트라나 슬랙의 피씬 채널에서 토의하는 것을 잊지 마세요!

- 예시를 꼼꼼히 살펴보세요. 과제에 명시되지 않은 상세한 부분들이 들어있을 수도 있으니까요..

<br>

# Chapter 3

## Today's specific rules

- 전역에 코드를 작성하지 마세요. 우리는 함수를 원해요!

- 다른 말이 명시되어 있지 않은 이상, 모든 제출 파일은 다음과 같이 끝나야 합니다 :
```
if __name__ == '__main__':
    여러분의_함수(필요하면, 사용할, 인자값을, 넣으세요)
```

- 에러 관리를 하셔도 좋습니다.

- 각 과제별 설명란의 'Authorized functions' 에 명시되어 있는 함수 / 라이브러리 외에는 import가 절대 금지됩니다.

- `python3` 인터프리터를 사용하세요.


<br>

# Chapter 4

## Exercise 00

<br>

| **Piscine**                | Exercise 00            |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| Exercise 00 : 중력을 거스르는 자               |
| **제출할 폴더**              | ex00/            |
| **제출할 파일**                 | `geohashing.py`         |
| **허용되는 함수**                   | `sys, antigravity`       |

<br>

이번 과제는 해당 pdf의 머리말 (preamble) 을 떠올리면서, 간단한 몸풀기를 해볼 겁니다. 하나도 안 어려워요.

`geohashing.py` 라는 프로그램을 만드세요. 필요한 만큼 인자값을 받고, geohash를 분명하게 계산한 후 그 결과물을 표준 출력으로 화면에 보여주어야 합니다.

에러가 발생했을 경우, 프로그램이 종료되기 전 적절한 에러 메시지를 화면에 보여야 합니다.

이 글이 도움이 될 거에요: [지오해싱 알고리즘](http://xkcd.com/426/)

<br>

# Chapter 5

## Exercise 01

<br>

| **Piscine**                | Exercise 01            |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| Exercise 01 : pip           |
| **제출할 폴더**              | ex01/            |
| **제출할 파일**                 | `my_script.sh my_program.py`         |
| **허용되는 함수**                   |    `path.py 모듈`    |

<br>

`path.py`는 Path 객체를 불러오도록 도우며, 이는 `os.path`를 조금 더 직관적으로 사용할 수 있게 돕습니다.

이번 과제에서는, 이 라이브러리를 설치하는 `bash` 스크립트를 만들고, 라이브러리를 사용하는 `Python` 프로그램을 작성해보도록 하겠습니다.

쉘 스크립트는 다음과 같은 절차를 지켜야 합니다:
- 당연히 확장자는 `.sh`여야 합니다. `쉘` 스크립트니까요.
- 반드시 pip의 버전을 표시하여야 합니다.
- 반드시 `path.py`의 개발자 버전을 `Github` 레포지토리로부터 받아서, 본인 과제 폴더 하위의 `local_lib` 폴더에 설치하여야 합니다. 만약 해당 폴더에 이미 설치되어 있다면, 재설치 시에 이를 부숴야 합니다. (crush it)
- `path.py` 설치 로그를 `.log` 확장자로 저장하여야 합니다.
- 라이브러리가 제대로 설치되었다면, 여러분이 만든 간단한 프로그램이 실행되어야 합니다.

파이썬 프로그램은 다음과 같은 절차만 제대로 지킨다면 자유롭게 구성하셔도 됩니다:
- 당연히 확장자는 `.py`여야 합니다. `파이썬`이니까요..
- 반드시 `path.py` 라이브러리를 방금 전에 쉘 스크립트로 설치한 경로로부터 불러와야 합니다.
- 프로그램은 반드시 폴더와 폴더 내부에 파일을 하나 만들어야 하고, 해당 파일에 아무 값을 쓴 다음 그것을 읽어들여 출력하는 과정이 필요합니다.
- 오늘의 규칙 ([**Today's specific rules**](#Chapter-3)) 을 따라야 합니다.


<br>

# Chapter 6

## Exercise 02

<br>

| **Piscine**                | Exercise 02            |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| Exercise 02 : API 리퀘스트하기              |
| **제출할 폴더**              | ex02/            |
| **제출할 파일**                 | `request_wikipedia.py requirement.txt`         |
| **허용되는 함수**                   |  `requests, json, dewiki, sys`    |

<br>

위키피디아는 여러분이 잘 알고 있는 놀라운 지식 공유의 장입니다. 또한 여러분이 가장 좋아하는 브라우저에서도 실행할 수 있고, 핸드폰으로도 실행 가능하죠. 이제 여러분에게 이 필수요소적인 웹사이트를 터미널에서 접근할 수 있는 도구를 만들 권리를 드리겠습니다.

그렇게 하기 위해선, `string` 형식의 패러미터를 받아 [위키피디아 API](https://www.mediawiki.org/wiki/API:Main_page)를 이용하여 검색하고, 그 결과값을 파일에 저장하는 `request_wikipedia.py` 프로그램을 만들어야 합니다. 프랑스 API나 영어 API 중 하나를 사용하시면 됩니다.

- 프로그램은 request에 오타가 나도 결과를 그대로 파일로 저장하여야 합니다. 원본 웹사이트에서 이것저것 넣어서 테스트해 보세요. 원본 웹사이트가 결과를 찾았다면, 여러분의 프로그램도 동일하게 작동해야 합니다.

- 결과값은 파일에 저장되기 전 `JSON`이나 `Wiki Markup` 형식으로 포맷되어선 안 됩니다!

- 파일명은 `검색한_키워드명.wiki`가 되어야 하고, 파일명에 공백이 있으면 안 됩니다.

- 받아온 패러미터가 없거나, 패러미터 형식이 이상하거나, 리퀘스트 오류가 발생하거나, 정보가 없거나, 서버 문제 등 오류가 발생하면, 파일이 생성되면 안 되며, 적절한 에러 메시지가 표시되어야 합니다.

- 여러분의 레포지토리에 `requirement.txt`를 포함하세요. 이는 여러분의 시스템이나 가상환경에 필요한 라이브러리를 설치하는 데에 사용됩니다.


<br>

# Chapter 7
## Exercise 03
​
<br>

| **Piscine**                | Exercise 03            |
| ---------------------------- | ------------------------------------ |
| Exercise 03 : 영광의 커피머씬!           |
| **제출할 폴더**              | ex03/            |
| **제출할 파일**                 | `machine.py, beverages.py`         |
| **허용되는 함수**                   | `import random`      |

<br>
​
짜잔! 여러분의 회사가 제대로 굴러가고 있군요! 여러분이 받은 첫 번째 기부금으로 회사 부지를 마련할 수 있었습니다. 여러분은 이제 커피를 내려줄 인턴도 있고 건물 입구에 경관 정돈용 10레벨짜리 식물도 있네요.

그렇지만 아직 모든 것이 완벽하지는 않습니다. 여러분 인턴이 만드는 커피는 맛이 기분나쁘도록 없어요! 이 흙덩어리에는 최저시급의 반도 아깝습니다. 그말인즉 여러분(만)의 성공을 위해 새로운 설비를 들일 때가 왔습니다!

다음 기능을 만족하는 `CoffeeMachine` 클래스를 만드세요:
- 생성자 (builder).

- `HotBeverage` 클래스를 상속하는 `EmptyCup` 클래스, 이름(name)은 _"empty cup"_, 가격(price)은 0.90이고 설명(description)은 _"An empty cup?! Gimme my money back!"_ 이어야 합니다.
내부의 클래스를 사용하기 위해 지난번 exercise의 `beverages.py` 파일을 복사해오세요.

- 예외(`Exception`) 클래스를 상속한 `BrokenMachineException` 클래스를 만들고, 텍스트(text)는 _"This coffee machine has to be repaired."_ 여야 합니다. 텍스트는 반드시 예외의 생성자(builder)에서 정의되어야 합니다.

- 커피머신을 고쳐서 다시 뜨거운 음료를 내릴 수 있게 할 `repair()` 메소드

- 다음 조건을 만족하는 `serve()` 메소드:
    - **인자**: `HotBeverage` 클래스에서 분기한 클래스를 인자로 받아들일 `self`가 아닌 특별한 인자

    - **반환값**: 메서드는 인자에 기반한 클래스 인스턴스나, _대안_(무작위로) 인스턴스로 `EmptyCup` 인스턴스를 반환합니다.

    - **노후화**: 기계가 싸구려라서 10번 사용하면 고장나 버립니다.

    - **고장났을 떄**: `serve()` 메소드를 호출하면 `repair()`메소드를 호출하기 전까지 `CoffeeMachine.BrokenMachineException`를 반환해야 합니다.

    - **수리하기**: `repair()` 메소드를 호출한 후 `serve()`메서드는 음료 10개를 내리(고 박살나)기 전까지 다시 예외를 일으키지 않고 정상적으로 작동해야 합니다.

테스트에서 `CoffeeMachine` 클래스의 인스턴스를 만드세요. 기계가 박살날 때까지 `beverages.py`파일의 의 다양한 음료들을 주문한 다음 나온 음료들을 출력하세요. (그 다음에는 선언된 예외들을 확인할 겁니다) 기계를 고친 후 기계가 다시 박살날 때까지 처음부터 다시 진행하세요. (예외를 처리해야 합니다... 다시!)
​
<br>

# Chapter 8
## Exercise 04
​
<br>

| **Piscine**                | Exercise 04            |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| Exercise 04 : 간단한 클래스 ft. RMS.                   |
| **제출할 폴더**              | ex04/            |
| **제출할 파일**                 | `elem.py`         |
| **허용되는 함수**                   |       |

<br>
​
이제 WEB 가시성 작업을 할 때가 왔습니다. 새롭게 익힌 파이썬 기술들로 HTML 컨텐츠들을 효율적으로 디자인하고 싶지만 그전에 _령도자_ 에게 어떻게 할 지조언을 받고 싶습니다.

여러분은 여러분 인턴을 제물로 바쳐 프로그래밍의 신을 소환하기로 했습니다.

커피머신도 있으니, 이제 인턴은 쓸모가 없습니다... 그냥 날려버려...
.

*성(聖) **IGNU**시우스*가 여러분 앞에 나타나 신성한 계시를 내립니다:

> HTML요소들의 구조는 거의 비슷하도다. (태그, 컨텐츠, 속성). 이들을 모두 다시 쓰는 것보다 파이썬 고대의 힘을 이용하여 겹치는 행동들과 사양을 엮을 클래스를 만들어 빠르고 편하게 이 클래스를 상속하는 것이 현명할 지어다.

말을 마치고 나서야 *성(聖) **IGNU**시우스* 는 여러분이 작업중이던 Mac:tm:®를... 보자마자 사색이 되어 빤스런 해버렸습니다. 덕분에 여러분에겐 테스트 파일과 미완성 클래스만 남았네요. 여러분은 서둘러 다음 조건을 만족하는 `Elem` 클래스를 만듭니다(채워야 할 빈칸은 `[...]`으로 표시됩니다):

- element의 이름, HTML attributes와 type(심플 또는 이중 태그)을 인자로 받아들이는 생성자(builder) .

- element의 HTML 코드를 반환하는 `__str__()` 메서드.

- 컨텐츠 끝에 elements를 추가할 수 있게 할 `add_content()` 메서드.

- 내장 `Exception` 서브 클래스.

일이 잘 진행된다면 아무 HTML element와 그 컨텐츠를 `Elem` 클래스를 이용하여 표현할 수 있을 것입니다. 이제 마지막으로:

- 부록에 타르볼로 제공된 `tests.py` 파일이 제대로 동작해야 합니다. (assertion error 금지, 테스트 결과가 명시적으로 '성공적'이라 출력).
물론, 우리가 구현하라 하지도 않은 기능을 테스트할 만큼 잔인하지야 않죠. 하하하... 우리가 그럴리가... 진짜로요.

- 또한 `Elem` 클래스의 도움을 받아 다음 구조를 모방하고 출력해야 합니다:

```html
<html>
  <head>
    <title>
      "Hello ground!"
    </title>
  </head>
  <body>
    <h1>
      "Oh no, not again!"
    </h1>
    <img src="http://i.imgur.com/pfp3T.jpg" />
  </body>
</html>
```

<br>

# Chapter 9
## Exercise 05
​
<br>

| **Piscine**                | Exercise 05            |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| Exercise 05 : 직접 요소 만들기!            |
| **제출할 폴더**              | ex05/            |
| **제출할 파일**                 | `elem.py`, `elements.py`         |
| **허용되는 함수**                   |       |

<br>
​
축하합니다! 이제 아무 HTML element와 컨텐츠를 만들 수 있게 되었네요. 하지만, 인스턴스들로 요소들을 각 속성들마다 생성해내는 건 좀 지루합니다. 그래서 여기 레거시 코드를 이용하여 훨씬 쓰기 쉬운 작은 클래스들을 만들어낼 기회가 있습니다. 지난 번 exercise에서 만들었던 Elem 클래스를 상속한 다음 클래스들을 만드세요:

- html, head, body
- title
- meta
- img
- table, th, tr, td
- ul, ol, li
- h1
- h2
- p
- div
- span
- hr
- br

각 클래스의 생성자는 컨텐츠를 첫 번째 인자로 받을 수 있어야 하고,
`print( Html( [Head(), Body()] ) )`
는 다음과 같은 결과를 내보내야 합니다.

```html
<html>
  <head></head>
  <body></body>
</html>
```

똑똑하게 일하세요! `Elem`을 작성할 때 구현했던 기능들을 재사용하세요. 반드시 상속을 사용해야 합니다.

이 클래스들이 어떻게 작동하는지 테스트 몇 가지로 - 선택 사항 - 기능들을 전부 시연해보세요. 이 클래스들을 작성한 뒤엔 태그의 이름이나 형식을 지정할 필요가 없어 아주 편리할 것입니다. 앞으로 다시는 `Elem` 클래스를 직접적으로 인스턴스화할 일이 없을 것입니다. 음, 엄밀히 말하자면, 앞으로 그렇게 하는 것이 *금지* 될 것입니다.

파생 클래스들을 사용하는 것이 _`Elem`_ 을 직접 사용하는 것보다 얼마나 좋은지 알아보기 위해, 지난번 exercise에서 만들어냈던 HTML 문서 구조를 다시 만들어봅시다. 반드시 새롭게 만든 클래스를 이용하여 모방해내야 합니다.

```html
<html>
  <head>
    <title>
      "Hello ground!"
    </title>
  </head>
  <body>
    <h1>
      "Oh no, not again!"
    </h1>
    <img src="http://i.imgur.com/pfp3T.jpg" />
  </body>
</html>
```

훨씬 간단하죠, 안그래요? : )

<br>

# Chapter 10
## Exercise 06
​
<br>

| **Piscine**                | Exercise 06            |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| Exercise 06: 검증하기.            |
| **제출할 폴더**              | ex06/            |
| **제출할 파일**                 | `Page.py, elem.py, elements.py`         |
| **허용되는 함수**                   |       |

<br>

여러분들이 그렇게 대단한 성과를 내었음에도 불구하고, 아직도 처리할 일들이 조금 남아 있습니다. 여러분은 지금 이런 기분이죠 : 누구보다 제약과 도전을 좋아하는데, `HTML` 문서 구조에 표준 규범 (Norm) 을 적용하는 건 어떨까? 이전 과제에서 만들었던 클래스들을 현재 과제 폴더에 복사하세요.

`Page` 클래스를 만드세요. 해당 클래스의 생성자 (builder) 는 "`Elem`을 상속받는 클래스 인스턴스"를 인자로 받아와야 합니다.

`Page` 클래스는 `is_valid()` 메소드를 이식해야 합니다. 해당 메소드는 다음의 모든 규칙을 지켰을 때 `True`를, 하나라도 지키지 않았을 때 `False`를 전송합니다.

- 만약, 트리 경로에 위치한 노드가 다음과 같은 타입이 아닐 때 : `html, head, body, title, meta, img, table, th, tr, td , ul, ol, li, h1, h2, p, div, span, hr, br 그리고 텍스트`, 해당 트리는 유효하지 않다고 판단합니다.

- `Html`은 엄격하게 Head **다음에** Body를 가져야 합니다.

- `Head`는 딱 하나의 `Title`만을 가져야 합니다.

- `Body`와 `Div`는 다음과 같은 요소들만을 가져야 합니다 : `H1, H2, Div, Table, Ul, Ol, Span, 그리고 텍스트`.

- `Title, H1, H2, Li, Th, Td`는 딱 하나의 `텍스트`만을 가져야 합니다.

- `p`는 `텍스트`만을 포함해야 합니다.

- `Span`은 `텍스트`와 `p`만을 포함해야 합니다.

- `Ul`과 `Ol`은 적어도 한 개의 `Li`만을 가져야 하며, `Li`외의 다른 종류의 요소는 불허합니다.

- `Tr`은 적어도 한 개 이상의 `Th` 또는 `Td`만을 가져야 하며, `Th`와 `Td` 끼리는 상호 배타적 (Mutually Exclusive)이어야 합니다.

- `Table`은 하위 원소로 `Tr`만을 가져야 합니다.

여러분의 `Page` 클래스는 다음과 같은 것도 가능해야 합니다:

- 인스턴스를 `출력` 할 때 `HTML` 코드를 화면에 보여줍니다. 조심하세요: `HTML` 코드는 루트 요소 타입이 `Html`일 때만 doctype 다음에 출력되어야 합니다.

- `write_to_file` 메소드를 이용하여 `HTML` 코드를 파일로 출력할 수 있어야 합니다. 해당 메소드는 파일명을 인자값으로 받습니다. 조심하세요: `HTML` 코드는 루트 요소 타입이 `Html`일 때만 doctype 다음에 이어서 저장되어야 합니다.

여러분이 정한 여러 테스트케이스에 대해 `Page` 클래스가 동작하는 것을 시연하고, 위의 모든 기능을 제대로 수행하는 것을 보이세요.
